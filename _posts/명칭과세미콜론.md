---
title: Golang과 명칭, 세미콜론
date: YYYY-MM-DD HH:MM:SS +09:00
categories: [Go, 개발]
tags:
  [
    go,
    oop,
    명칭,
    세미콜론
  ]
---


# 명칭
go에서의 이름은 매우 중요하다. 이름의 대소문자 유무에 따라 패키지 노출 여부도 결졍된다.

### 패키지명

패키지가 임포트되면, 패키지명은 패키지 내용들에 대한 접근자가 된다.

```go
import "bytes"
```

모든 사람들이 패키지 내용을 참조하기 위해 같은 이름을 사용할 수 있다는 건 패키지명이 잘 작성되어야 함(짧고, 간결하고, 연상하기 쉬운)을 의미한다. 

1. 관례적으로 패키지명은 소문자, 한 단어로만 부여하며 언더바(_)나 대소문자 혼용에 대한 필요가 없어한다.

이는 간결함이 이유인데, 패키지를 사용할 모든 사람들이 패키지명을 직접 타이핑할 것이기 때문.

충돌에 대한 걱정은, 패키지명은 오직 임포트를 위한 이름이라서 모든 소스코드에서 유일한 필요는 없고

충돌할때는 국지적으로 다른 이름을 선택할 수 있다.

1. 패키지명은 소스 디렉토리 이름 기반이어야한다. 

패키지를 임포트하는 입장에서는 패키지 내용을 참조하기 위해 패키지명을 사용한다. 그래서 패키지 밖으로 노출되는 이름들은 이름의 지저분함을 피하기위해 이러한 사실을 활용할 수 있다. (import . 표현은 사용하면 안된다. 이는 테스트를 수행중인 패키지의 외부에서 필수적으로 실행해야하는 테스트를 단순화 할 순 있지만 이를 피해야한다.)

(ex. bufio.Reader → O, bufio.bufReader → X) 명확, 간결

임포트된 객체들은 항상 패키지명과 함께 불려지기 대문에 충돌하지도 않는다. (ex. io.Reader, bufio.Reader)

go에 존재하는 ring.Ring 이라는 객체를 builder pattern 으로 만들 시, 패키지 자체가 ring으로 불리기 때문에

ring.NewRing이 아닌 ring.new로 사용한다.

결국 간결함이 생명이다.


### 게터 (Getters)

go에서는 getter와 setter를 자체적으로 제공하진 않는다.

 스스로 getter 와 setter를 만들어 사용하면 되는데 이는 전혀 문제될게 없으며 이는 적절하고 일반적인 방법이다. (go에서는 getter 이름에 get을 넣는게 필수는 아니다. )

만약 owner라는 이름을 가진 필드가 있다면 getter메서드는 GetOwner가 아닌 Owner 라고 불러야 한다.

패키지밖으로 노출하기 위해 대문자 이름을 사용하는 것은 메서드로부터 필드를 식별할 수 있는 훅을 제공한다.

만약 필요하다면 setter 함수는 SetOwner라고 불릴것이다.

```go
owner := obj.Owner()
if owner != user {
    obj.SetOwner(user)
}
```

### 인터페이스명

관례적으로, 하나의 메서드를 갖는 인터페이스는 메서드이름에 -er 접미사를 붙이거나 에이전트 명사를 구성하는 유사한 변형에 의해 지정된다.

예를 들어 Reader, Writer, Formatter 등이 있다.

이런 류의 이름들이 있고, 이것들과 이것들을 통해 알 수 있는 함수이름들을 지켜나가는 것은 생산적이다. Read, Write, Close, Flush, String 등등은 각각의 용법과 의미를 가지고 있다. 

혼란을 피하기 위해 같은 용법과 의미를 가지지 않는 한 메서드에 이 이름들과 같은 이름들을 쓰지 마라. 

반대로 말하면, 만약 당신이 구현한 타입에 이미 잘 알려진 타입들이 가지고 있는 메서드들과 같은 의미를 갖는 메서드를 구현하려고 한다면, 같은 이름을 부여하면 된다. 문자 변환 메서드를 만든다면 ToString이 아닌, String을 사용하라

### 대소문자 혼합

마지막으로 Go에서의 네이밍 규칙은 여러 단어로된 이름을 명명할 때, 언더바 대신 대소문자 혼합을 사용하는 것이다.
